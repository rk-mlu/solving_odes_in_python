# #if FORMAT == 'ipynb'
========= Programming a simple ODE solver =========
# #endif
idx{ordinary differential equation} 
Ordinary differential equations (ODEs) are widely used in science and engineering, in particular for modeling dynamic
processes. While simple ODEs can be solved with analytical methods, non-linear ODEs are generally not possible
to solve in this way, and we need to apply numerical methods. In this chapter we will see how we can program
general numerical solvers that can be applied to any ODE. We will first consider scalar ODEs, i.e., ODEs with a single
equation and a single unknown, and in Section ref{sec:ode_sys} we will
extend the ideas to systems of coupled ODEs. Understanding the concepts
of this chapter is useful not only for programming your own ODE solvers, but also for using a wide variety of
general-purpose ODE solvers available both in Python and other programming languages.


======= Creating a general-purpose ODE solver =======
label{sec:fe_intro}
When solving ODEs analytically one will typically consider a specific ODE or a class of ODEs, and try to derive
a formula for the solution. In this chapter we want to implement numerical solvers that can be applied to any ODE,
not restricted to a single example or a particular class of equations. For this purpose, we need a general abstract
notation for an arbitrary ODE. We will write the ODEs on the following form:
!bt
\begin{equation}
u^{\prime}(t) = f(t,u(t)),
label{ode0}
\end{equation}
!et
which means that the ODE is fully specified by the definition of the right-hand side function $f(t,u)$. Examples of this
function may be:
!bt
\begin{align*}
f(t,u) &= \alpha u,\quad\hbox{exponential growth}\\
f(t,u) &= \alpha u\left(  1-\frac{u}{R}\right),\quad\hbox{logistic growth}\\
f(t,u) &= -b|u|u + g,\quad\hbox{falling body in a fluid}
\end{align*}
!et
Notice that, for generality, we write all these right-hand sides as functions of both $t$ and $u$, although the
mathematical formulations only involve $u$. This general formulation is not strictly needed in the
mathematical equations, but it is very convenient when we start programming, and want to use the same solver
for a wide range of ODE models. We will discuss this in more detail later. 
Our aim is now to write functions and classes that take $f$ as input, and solve the corresponding ODE to produce
$u$ as output.
idx{exponential growth} idx{logistic growth}

In order for (ref{ode0}) to have a unique solution we need to specify the *initial condition* for $u$, which is 
the value of the solution at time $t=t_0$. The resulting mathematical problem is written as
!bt
\begin{align*}
u^{\prime}(t) &= f(t,u(t)),\\
u(t_0) &= u_0 ,
\end{align*}
!et
and is commonly referred to as an *initial value problem*, or simply an IVP. All the ODE problems we will consider 
in this book are initial value problems. As an example, consider the very simple ODE
!bt
\[ u'=u .\]
!et
This equation has the general solution $u=Ce^t$ for any constant $C$, so it has an infinite number of solutions.
Specifying an initial condition $u(t_0)=u_0$ gives $C=u_0$, and we get the unique solution $u=u_0e^t$.  
We shall see that, when solving the equation numerically, we need to define $u_0$ in order to start our method and
compute a solution at all.

idx{forward Euler method} idx{Euler method !explicit}
=== A simple and general solver; the Forward Euler method. ===
A numerical method for (ref{ode0}) can be derived by simply approximating the derivative
in the equation $u'=f(t,u)$ by a finite difference. To introduce the idea, assume that we have 
already computed $u$ at discrete time points $t_0,t_1,\ldots,t_n$. At time $t_n$ we have the ODE
!bt
\[ u'(t_n) = f(t_n,u(t_n)), \]
!et
and we can now approximate $u'(t_n)$ by a forward finite difference;
!bt
\[ u'(t_n)\approx \frac{u(t_{n+1})-u(t_n)}{\Delta t} .\]
!et
Inserting this approximation into the ODE at $t=t_n$ yields the following equation
!bt
\[ \frac{u(t_{n+1})-u(t_n)}{\Delta t} = f(t_n,u(t_n)), \]
!et
and we can rearrange the terms to obtain an explicit formula for $u(t_{n+1})$:
!bt
\[ u(t_{n+1}) = u(t_n) + \Delta t f(t_n,u(t_n)) .\]
!et
This method is known as the *Forward Euler (FE) method* or the *Explicit Euler Method*,
and is the simplest numerical method for solving an ODE. The classification as a *forward*
or *explicit* method refer to the fact that we have an explicit update formula for $u(t_{n+1})$,
which only involves known quantities at time $t_n$. In contrast, for an *implicit* ODE solver
the update formula will include terms on the form $f(t_{n+1},u(t_{n+1})$, and we need to solve 
a generally nonlinear equation to determine the unknown $u(t_{n+1})$. We will visit other explicit ODE solvers in
Chapter ref{ch:runge_kutta} and implicit solvers in Chapter ref{ch:stiff}. 

To simplify the formula a bit we introduce the notation $u_{n} = u(t_{n})$, i.e., 
we let $u_n$ denote the numerical approximation to the exact solution $u(t)$ at $t=t_n$.
The update formula now reads 
!bt
\begin{equation} u_{n+1} = u_n + \Delta t f(t_n,u_n) ,
label{forw_euler}
\end{equation}
!et
which, if we know the $u_0$ at time $t_0$, can be applied repeatedly to $u_1$, $u_2$, $u_3$ and so forth.
If we again consider the very simple ODE given by $u' = u$, we have 
!bt
\begin{align*}
u_1 &= u_0 + \Delta t u_0, \\
u_2 &= u_1 + \Delta t u_1, \\
u_3 &= u_2 + \ldots .
\end{align*}
!et
In a Python program, this repeated application
of the same formula is conveniently implemented in a for-loop, and the solution can 
be stored in a list or a NumPy array. See, for instance, cite{sundnes2020introduction} for an introduction to
NumPy arrays and tools, which will be used extensively through these notes. 
For a given final time $T$ and number of time steps $N$, 
we perform the following steps:
 o Create arrays `t` and `u` of length $N+1$[^steps_note]
 o Set initial condition: `u[0]` $= u_0$, `t[0]` $= 0$
 o Compute the time step $\Delta t$ (`dt`) $= T/N$
 o For $n=0,1,2,\ldots,N-1$:
  * `t[n+1] = t[n] + dt`
  * `u[n+1] = (1 + dt)*u[n]`
idx{NumPy array}
# #if FORMAT != 'ipynb'
[^steps_note]: For $N$ time steps, the length of the arrays needs to be $N+1$ since
we need to store both end points, i.e., $t_0,t_1, \ldots, t_n$ and $u_0,u_1, \ldots, u_n$. 
# #endif

A complete Python implementation of this algorithm may look like
!bc pycod
import numpy as np
import matplotlib.pyplot as plt

N = 20
T = 4
dt = T/N
u0 = 1

t = np.zeros(N+1)
u = np.zeros(N+1)

u[0] = u0
for n in range(N):
    t[n+1] = t[n] + dt
    u[n+1] = (1 + dt)*u[n]

plt.plot(t,u)
plt.show()
!ec
Notice that there is no need to set `t[0]= 0` when `t` is created in this way, but updating `u[0]` is important. In fact, 
forgetting to do so is a very common error in ODE programming, so it is worth taking note of the line `u[0] = u0`
The solution is shown in Figure ref{fig:ode0}, for two different choices of the time step $\Delta t$. We see that the
approximate solution improves as $\Delta t$ is reduced, although both the solutions are quite inaccurate. However, reducing the
time step further will easily create a solution that cannot be distinguished from the exact solution.

FIGURE: [../chapters/fig-ode2/FE_n_10_20, width=600 frac=1] Solution of $u' = u, u(0) = 1$ with $\Delta t = 0.4 (N=10)$ and $\Delta t=0.2 (N=20)$. label{fig:ode0}

=== Extending the solver to the general ODE. ===
As stated above, the purpose of this chapter is to create general-purpose ODE solvers, that can solve any ODE written
on the form $u'=f(t,u)$. This requires a very small modification of the algorithm above;
 o Create arrays `t` and `u` of length $N+1$
 o Set initial condition: `u[0]` = $u_0$, `t[0]=0`
 o For $n=0,1,2,\ldots,N-1$:
  * `t[n+1] = t[n] + dt`
  * `u[n+1] = u[n] + dt*f(t[n], u[n])`

The only change of the algorithm is in the formula for computing `u[n+1]` from `u[n]`.
In the previous case we had $f(t,u) = u$, and to create a
general-purpose ODE solver we simply replace `u[n]` with the more general `f(t[n],u[n])`.
The following Python function implements this generic version of the FE method:
!bc pycod
def forward_euler(f, u0, T, N):
    """Solve u'=f(t,u), u(0)=u0, with n steps until t=T."""
    import numpy as np
    t = np.zeros(N+1)
    u = np.zeros(N+1)  # u[n] is the solution at time t[n]

    u[0] = u0
    dt = T/N

    for n in range(N):
        t[n+1] = t[n] + dt
        u[n+1] = u[n] + dt*f(t[n], u[n])

    return t, u
!ec
This simple function can solve any ODE written on the form (ref{ode0}). The right-hand 
side function $f(t,u)$ needs to be implemented as a Python function, which is
then passed as an argument to `forward_euler` together with the initial condition `u0`, the
stop time `T` and the number of time steps `N`. The two latter arguments are then used
to calculate the time step `dt` inside the function.

To illustrate how the function is used, let us apply it to solve the same problem as above;
$u'=u$, $u(0)=1$, for $t\in [0,4]$. The following code uses the `forward_euler` function to solve this problem:
!bc pycod
def f(t, u):
    return u

u0 = 1
T = 3
N = 30
t, u = forward_euler(f, u0, T, N)
!ec
The `forward_euler` function returns the two arrays `u` and `t`, which we can
plot or process further as we want. One thing worth noticing in this code is the definition of the
right-hand side function `f`. As we mentioned above, this function should always be written
with two arguments `u` and `t`, although in this case only `u` is used inside the function.
The two arguments are needed because we want our solver to work for all ODEs on the
form $u' = f(t,u)$, and the function is therefore called as `f(t[n], u[n])` inside
the `forward_euler` function. If our right
hand side function was defined as a function of `u` only, i.e., using `def f(u):`, 
we would get an error message when the function was called inside `forward_euler`. 
This problem is solved by simply writing `def f(t,u):` even if `t` is never used 
inside the function.[^rhs_note]

# #if FORMAT != 'ipynb'
[^rhs_note]: This way of defining the right-hand side is a standard used by most
available ODE solver libraries, both in Python and other languages. The right-hand
side function always takes two arguments `t` and `u`, but, annoyingly, the order of the
two arguments varies between different solver libraries. Some expect the `t` argument first,
while others expect `u` first.
# #endif

For being only 15 lines of Python code, the capabilities of the `forward_euler`
function above are quite remarkable. Using this function, we can solve any
kind of linear or nonlinear ODE, most of which would be impossible to solve
using analytical techniques. The general recipe for using this function can be summarized
as follows:
 o Identify $f(t,u)$ in your ODE
 o Make sure you have an initial condition $u_0$
 o Implement the $f(t,u)$ formula in a Python function `f(t, u)`
 o Choose the number of time steps `N`
 o Call `t, u = forward_euler(f, u0, T, N)`
 o Plot the solution

It is worth mentioning that the FE method is the simplest of all
ODE solvers, and many will argue that it is not very good. This is partly true,
since there are many other methods that are more accurate and more stable when applied to
challenging ODEs. We shall look at a few examples of such methods later in this
book. However, the FE method is quite suitable for solving most ODEs.
If we are not happy with the accuracy we can simply reduce the time step, and
in most cases this will give the accuracy we need with a negligible increase in computing time.


======= The ODE solver implemented as a class =======
label{sec:fe_class} 
idx{`ForwardEuler` class}
We can increase the flexibility of the `forward_euler`
solver function by implementing it as a class. There are many ways to implement
and such a class, but one possible usage can be as follows:
!bc pycod-t
method = ForwardEuler_v0(f) 
method.set_initial_condition(u0)
t, u = method.solve(t_span=(0,10),N=100)
plot(t, u)
!ec
idx{class !for ODE solver}
The benefits of using a class instead of a function may not be obvious at this
point, but it will become clear when we introduce different ODE solvers later. 
For now, let us just look at how such a solver class would need to be implemented in 
order to support the use case specified above:
  * We need a constructor (`__init__`) which takes a single argument, the right-hand side function `f`, 
    and stores it as an attribute.
  * The method `set_initial_condition` takes the initial condition as argument and stores it. 
  * The class needs a `solve`-method, which takes the time interval `t_span` and number of time steps `N`
    as arguments. The method implements the for-loop for solving the ODE and returns
    the solution, similar to the `forward_euler` function considered earlier.
  * The time step $\Delta t$ and the sequences $t_n$, $u_n$ must be
    initialized in one of the methods, and it may also be convenient to store these as attributes. 
    Since the time interval and the number of steps are arguments to the `solve` method it is natural
    to do these computations there.

In addition to these methods, it may be convenient to implement the formula for
advancing the solution one step as a separate method `advance`. In this way it
becomes very easy to implement new numerical methods, since we typically only
need to change the `advance` method. A first version of the solver class may
look as follows:
!bc pycod
import numpy as np

class ForwardEuler_v0:
    def __init__(self, f): 
        self.f = f 
        
    def set_initial_condition(self,u0):
        self.u0 = u0

    def solve(self,t_span,N):
        """Compute solution for 
        t_span[0] <= t <= t_span[1],
        using N steps."""
        t0,T = t_span
        self.dt = T/N
        self.t = np.zeros(N+1) 
        self.u = np.zeros(N+1)
        
        self.t[0] = t0
        self.u[0] = self.u0
        
        for n in range(N):
            self.n = n
            self.t[n+1] = self.t[n] + self.dt
            self.u[n+1] = self.advance()
        return self.t, self.u

    def advance(self):
        """Advance the solution one time step."""
        u, dt, f, n, t = self.u, self.dt, self.f, self.n, self.t

        unew = u[n] + dt*f(t[n],u[n])
        return unew
!ec
This class does essentially the same tasks as the `forward_euler` function above,
and the main advantage of the class implementation is
the increased flexibility that comes with the `advance` method. As we shall see
later, implementing a different numerical method typically only requires
implementing a new version of this method, while all other code can be left unchanged.

We can also use a class to hold the right-hand side $f(t,u)$, which is
particularly convenient for functions with parameters.
Consider for instance the model for logistic growth;
!bt
\[ u^{\prime}(t)=\alpha u(t)\left(  1-\frac{u(t)}{R}\right),\quad u(0)=u_0,\quad t\in [0,40],\]
!et
which is typically used to model self-limiting growth of a biological population, i.e., growth 
that is constrained by limited resources. The initial growth is approximately exponential, with
growth rate $\alpha$, and the population curve flattens out as the population size approaches the *carrying capacity* $R$,
see Figure ref{fig:logistic} for an example solution. 
The right hand side function includes two parameters $\alpha$ and $R$, but if we
want to solve it using our FE function or class, it must be implemented
as a function of $t$ and $u$ only. There are several ways to do this in Python, but one
convenient approach is to implement the function as a class with a call method. 
We can then define the parameters as attributes in the constructor and
use them inside the `__call__` method:
!bc pycod
class Logistic:
    def __init__(self, alpha, R, u0):
        self.alpha = alpha
        self.R = R 
        self.u0 = u0

    def __call__(self, t, u):   # f(t,u)
        return self.alpha*u*(1 - u/self.R)
!ec
idx{class !for right-hand side}
The main program for solving the logistic growth problem may now look like:
!bc pycod
problem = Logistic(alpha=0.2, R=1.0, u0=0.1)
solver = ForwardEuler_v0(problem)
solver.set_initial_condition(problem.u0)
    
t, u = solver.solve(T=40,N=400)
!ec

FIGURE: [../chapters/fig-ode2/logistic_func_mpl, width=600 frac=1.0] Solution of the logistic growth model. label{fig:logistic}
