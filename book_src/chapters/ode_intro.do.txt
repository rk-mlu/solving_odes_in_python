# #if FORMAT == 'ipynb'
========= Programming a simple ODE solver =========
# #endif

Ordinary differential equations (ODEs) are widely used in science and engineering, in particular for modeling dynamic
processes. While simple ODEs can be solved with analytical methods, non-linear ODEs are generally not possible
to solve in this way, and we need to apply numerical methods. In this chapter we will see how we can program
general numerical solvers that can be applied to any ODE. We will first consider scalar ODEs, i.e., ODEs with a single
equation and a single unknown, and in Chapter ref{ch:ode_sys} we will
extend the ideas to systems of coupled ODEs. Understanding the concepts
of this chapter is useful not only for programming your own ODE solvers, but also for using a wide variety of
general-purpose ODE solvers available both in Python and other programming languages.


======= Creating a general-purpose ODE solver =======
label{sec:fe_intro}
When solving ODEs analytically one will typically consider a specific ODE or a class of ODEs, and try to derive
a formula for the solution. In this chapter we want to implement numerical solvers that can be applied to any ODE,
not restricted to a single example or a particular class of equations. For this purpose, we need a general abstract
notation for an arbitrary ODE. We will write the ODEs on the following form:
!bt
\begin{equation}
u^{\prime}(t) = f(u(t), t),
label{ode0}
\end{equation}
!et
which means that the ODE is fully specified by the definition of the right hand side function $f(u,t)$. Examples of this
function may be:
!bt
\begin{align*}
f(u,t) &= \alpha u,\quad\hbox{exponential growth}\\
f(u,t) &= \alpha u\left(  1-\frac{u}{R}\right),\quad\hbox{logistic growth}\\
f(u,t) &= -b|u|u + g,\quad\hbox{falling body in a fluid}
\end{align*}
!et
Notice that for generality we write all these right hand sides as functions of both $u$ and $t$, although the
mathematical formulations only involve $u$. It will become clear later why such a general formulation is useful.
Our aim is now to write functions and classes that take $f$ as input, and solve the corresponding ODE to produce
$u$ as output.

=== A simple and general solver; the Forward Euler method. ===
All the numerical methods we will considered in this chapter are based on approximating the derivatives
in the equation $u'=f(u,t)$ by finite differences. To introduce the idea, assume that we have 
computed $u$ at discrete time points $t_0,t_1,\ldots,t_n$. At time $t_n$ we have the ODE
!bt
\[ u'(t_n) = f(u(t_n),t_n), \]
!et
and we can now approximate $u'(t_n)$ by a forward finite difference;
!bt
\[ u'(t_n)\approx \frac{u(t_{n+1})-u(t_n)}{\Delta t} .\]
!et
Inserting this approximation into the ODE at $t=t_n$ yields the following equation
!bt
\[ \frac{u(t_{n+1})-u(t_n)}{\Delta t} = f(u(t_n),t_n), \]
!et
and we can rearrange the terms to obtain an explicit formula for $u(t_{n+1})$:
!bt
\[ u(t_{n+1}) = u(t_n) + \Delta t f(u(t_n), t_n) .\]
!et
This method is known as the *Forward Euler (FE) method* or the *Explicit Euler Method*,
and is the simplest numerical method for solving an ODE. The classification as a *forward*
or *explicit* method referw to the fact that we have an explicit update formula for $u(t_{n+1}$,
which only involves known quantities at time $t_n$. In contrast, for an *implicit* ODE solver
the update formula will include terms on the form $f(u(t_{n+1),t_{n+1})$, and we need to solve 
a generally nonlinear equation to determine the unknown $u(t_{n+1})$. We will visit other explicit ODE solvers in
Chapter ref{ch:runge_kutta} and implcit solvers in ref{ch:stiff}. 

To simplify the formula a bit we introduce the notation $u_{n} = $u(t_{n})$, i.e., 
we let $u_n$ denote the numerical approximation to the exact solution $u(t)$ at $t=t_n$.
The update formula now reads 
!bt
\begin{equation} u_{n+1} = u_n + \Delta t f(u_n,t_n) ,
label{forw_euler}
\end{equation}
!et
which, if we know the $u_0$ at time $t_0$, can be applied repeatedly to $u_1$, $u_2$, $u_3$ and so forth.

=== An ODE needs an initial condition. ===
In mathematics, an initial condition for $u$ must be specified to have a unique solution of equation
(ref{ode0}). When solving the equation numerically, we need to set $u_0$ in order to start our method and
compute a solution at all. As an example, consider the very simple ODE
!bt
\[ u'=u .\]
!et
This equation has the general solution $u=Ce^t$ for any constant $C$, so it has an infinite number of solutions.
Specifying an initial condition $u(0)=u_0$ gives $C=u_0$, and we get the unique solution $u=u_0e^t$. An ODE with 
a corresponding initial condition is often referred to as an *initial value problem*, and all the ODE problems
we will consider in this book can be classified as such. When solving an initial value problem
equation numerically, we start from our known $u_0$, and apply formula (ref{forw_euler}) repeatedly:
!bt
\begin{align*}
u_1 &= u_0 + \Delta t u_0, \\
u_2 &= u_1 + \Delta t u_1, \\
u_3 &= u_2 + \ldots .
\end{align*}
!et
In a Python program, this repeated application
of the same formula is conveniently implemented in a for-loop, and the solution can 
be stored in a list or a NumPy array. For a given final time $T$ and number of time steps $N$, 
we perform the following steps:
 o Create arrays `t` and `u` of length $N+1$[^steps_note]
 o Set initial condition: `u[0]` $= U_0$, `t[0]` $= 0$
 o Compute the time step $\Delta t$ (`dt`) $= T/N$
 o For $n=0,1,2,\ldots,N-1$:
  * `t[n+1] = t[n] + dt`
  * `u[n+1] = (1 + dt)*u[n]`

# #if FORMAT != 'ipynb'
[^step_note]: For $N$ time steps, the length of the arrays needs to be $N+1$ since
we need to store both end points, i.e., $t_0,t_1, \ldots, t_n$ and $u_0,u_1, \ldots, u_n$. 
# #endif

A complete Python implementation of this algorithm may look like
!bc pycod
import numpy as np
import matplotlib.pyplot as plt

N=20
T = 4
dt = T/N
U0 = 1

t = np.zeros(N+1)
u = np.zeros(N+1)

u[0] = U0
for n in range(N):
    t[n+1] = t[n] + dt
    u[n+1] = (1 + dt)*u[n]

plt.plot(t,u)
plt.show()
!ec
Notice that there is no need to set `t[0]= 0` when `t` is created in this way, but updating `u[0]` is important. (And forgetting
to do so is a very common error in ODE programming.)
The solution is shown in Figure ref{fig:ode0}, for two different choices of the time step $\Delta t$. We see that the
approximate solution improves as $\Delta t$ is reduced, although both the solutions are quite inaccurate. However, reducing the
time step further will easily create a solution that cannot be distinguished from the exact solution.

FIGURE: [../chapters/fig-ode2/FE_n_10_20, width=600 frac=1] Solution of $u' = u, u(0) = 1$ with $\Delta t = 0.4$ and $\Delta t=0.2$. label{fig:ode0}

=== Extending the solver to the general ODE. ===
As stated above, the purpose of this chapter is to create general-purpose ODE solvers, that can solve any ODE written
on the form $u'=f(u,t)$. This requires a very small modification of the algorithm above;
 o Create arrays `t` and `u` of length $N+1$
 o Set initial condition: `u[0]` = $u_0$, `t[0]=0`
 o For $n=0,1,2,\ldots,N-1$:
  * `t[n+1] = t[n] + dt`
  * `u[n+1] = u[n] + dt*f(u[n], t[n])`

The only change of the algorithm is in the formula for computing `u[n+1]` from `u[n]`.
In the previous case we had $f(u,t) = u$, and to create a
general-purpose ODE solver we simply replace `u[n]` with the more general `f(u[n],t[n])`.
The following Python function implements this generic version of the FE method:
!bc pycod
def ForwardEuler(f, U0, T, N):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    import numpy as np
    t = np.zeros(N+1)
    u = np.zeros(N+1)  # u[n] is the solution at time t[n]

    u[0] = U0
    dt = T/N

    for n in range(N):
        t[n+1] = t[n] + dt
        u[n+1] = u[n] + dt*f(u[n], t[n])

    return u, t
!ec
This simple function can solve any ODE written on the form (ref{ode0}). The right
hand side function $f(u,t)$ needs to be implemented as a Python function, and
then passed as an argument to `ForwardEuler` together with the initial condition, the
stop time `T` and the number of time steps. The two latter arguments are then used
to calculate the time step `dt` inside the function.

To illustrate how the function is used, let us apply it to solve the same problem as above;
$u'=u$, $u(0)=1$, for $t\in [0,4]$. The following code uses the `ForwardEuler` function to solve this problem:
!bc pycod
def f(u, t):
    return u

U0 = 1
T = 3
N = 30
u, t = ForwardEuler(f, U0, T, N)
!ec
The `ForwardEuler` function returns the two arrays `u` and `t`, which we can
plot or process further as we want. One thing worth noticing in this code is the definition of the
right hand side function `f`. As we mentioned above, this function should always be written
with two arguments `u` and `t`, although in this case only `u` is used inside the function.
The two arguments are needed because we want our solver to work for all ODEs on the
form $u' = f(u,t)$, and the function is therefore called as `f(u[n], t[n])` inside
the `ForwardEuler` function. If our right
hand side function was defined as a function of `u` only, i.e., using `def f(u):`, 
we would get an error message when the function was called inside `ForwardEuler`. 
This problem is solved by simply writing `def f(u,t):` even if `t` is never used 
inside the function.[^rhs_note]

# #if FORMAT != 'ipynb'
[^rhs_note]: This way of defining the right hand side is a standard used by most
available ODE solver libraries, both in Python and other languages. The right hand
side function always takes two arguments `u` and `t`, but, annoyingly, the order of the
two arguments varies between different solver libraries. Some expect the `t` argument first,
while others expect `u` first.
# #endif

For being only 15 lines of Python code, the capabilities of the `ForwardEuler`
function above are quite remarkable. Using this function, we can solve any
kind of linear or nonlinear ODE, most of which would be impossible to solve
using analytical techniques. The general recipe for using this function can be summarized
as follows:
 o Identify $f(u,t)$ in your ODE
 o Make sure you have an initial condition $u_0$
 o Implement the $f(u,t)$ formula in a Python function `f(u, t)`
 o Choose the number of time steps `N`
 o Call `u, t = ForwardEuler(f, U0, T, N)`
 o Plot the solution

It is worth mentioning that the FE method is the simplest of all
ODE solvers, and many will argue that it is not very good. This is partly true,
since there are many other methods that are more accurate and more stable when applied to
challenging ODEs. We shall look at a few examples of such methods later in this
book. However, the FE method is quite suitable for solving most ODEs.
If we are not happy with the accuracy we can simply reduce the time step, and
in most cases this will give the accuracy we need with a negligible increase in computing time.


======= The ODE solver implemented as a class =======
label{sec:fe_class}
We can increase the flexibility of the `ForwardEuler`
solver function by implementing it as a class. The usage of the class
may for instance be as follows:
!bc pycod-t
method = ForwardEuler_v1(f, U0=0.0, T=40, N=400)
u, t = method.solve()
plot(t, u)
!ec
The benefits of using a class instead of a function may not be obvious at this
point, but it will become clear when we introduce different ODE solvers later. 
For now, let us just look at how such a solver class would need to be implemented in 
order to support the use case specified above:
  * We need a constructor (`__init__`) which takes `f`, `T`, `N`, and `U0` as arguments
    and stores them as attributes.
  * The class needs a `solve`-method, which implements the for-loop and returns
    the solution, similar to the `ForwardEuler` function considered earlier.
  * The time step $\Delta t$ and the sequences $u_n$, $t_n$ must be
    initalized and stored as attributes. These tasks are natural to handle in the constructor.

In addition to these methods, it may be convenient to implement the formula for
advancing the solution one step as a separate method `advance`. In this way it
becomes very easy to implement new numerical methods, since we typically only
need to change the `advance` method. A first version of the solver class may
look as follows:
!bc pycod
import numpy as np

class ForwardEuler_v1:
    def __init__(self, f, U0, T, N):
        self.f, self.U0, self.T, self.N = f, U0, T, N
        self.dt = T/N
        self.u = np.zeros(self.N+1)
        self.t = np.zeros(self.N+1)

    def solve(self):
        """Compute solution for 0 <= t <= T."""
        self.u[0] = float(self.U0)

        for n in range(self.N):
            self.n = n
            self.t[n+1] = self.t[n] + self.dt
            self.u[n+1] = self.advance()
        return self.u, self.t

    def advance(self):
        """Advance the solution one time step."""
        # Create local variables to get rid of "self." in
        # the numerical formula
        u, dt, f, n, t = self.u, self.dt, self.f, self.n, self.t

        unew = u[n] + dt*f(u[n], t[n])
        return unew
!ec
This class does essentially the same tasks as the `ForwardEuler` function above.
The main advantage of the class implementation is
the increased flexibility that comes with the `advance` method. As we shall see
later, implementing a different numerical method typically only requires
implementing a new version of this method, while all other code can be left unchanged.

We can also use a class to hold the right-hand side $f(u,t)$, which is
particularly convenient for functions with parameters.
Consider for instance the model for logistic growth;
!bt
\[ u^{\prime}(t)=\alpha u(t)\left(  1-\frac{u(t)}{R}\right),\quad u(0)=U_0,\quad t\in [0,40],\]
!et
which is typically used to model self-limiting growth of biological population, i.e., growth 
that is constrained by limited resources. The initial growth is approximately exponential, with
growth rate $\alpha$, and flattens out as the population size approaches the *carrying capacity* $R$. 
The right hand side function has two parameters $\alpha$ and $R$, but if we
want to solve it using our `ForwardEuler` function or class, it must be implemented
as a function of $u$ and $t$ only. There are several ways to do this in Python, but one
convenient approach is to implement the function as a class with a call method. 
We can then define the parameters as attributes in the constructor and
use them inside the `__call__` method:
!bc pycod
class Logistic:
    def __init__(self, alpha, R, U0):
        self.alpha, self.R, self.U0 = alpha, float(R), U0

    def __call__(self, u, t):   # f(u,t)
        return self.alpha*u*(1 - u/self.R)
!ec
The main program for solving the logistic growth problem may now look like:
!bc pycod
problem = Logistic(0.2, 1, 0.1)
method = ForwardEuler_v1(problem,problem.U0,40,401)
u, t = method.solve()
!ec

FIGURE: [../chapters/fig-ode2/logistic_func_mpl, width=600 frac=1.0] Solution of the logistic growth model.

=== An alternative class implementation of the FE method. ===
As always in programming, there are multiple ways to perform the same task, and the
`ForwardEuler_v1` class presented above is by no means the only possible class implementation of the
FE method. A possible alternative implementation is
!bc pycod
import numpy as np

class ForwardEuler_v2:
    def __init__(self, f):
        self.f = f

    def set_initial_condition(self,U0):
        self.U0 = float(U0)

    def solve(self, time_points):
        """Compute solution for array of time points"""
        self.t = np.asarray(time_points)
        N = len(self.t)
        self.u = np.zeros(N)
        self.u[0] = self.U0

        # Time loop
        for n in range(N-1):
            self.n = n
            self.u[n+1] = self.advance()
        return self.u, self.t

    def advance(self):
        """Advance the solution one time step."""
        # Create local variables to get rid of "self." in
        # the numerical formula
        u, f, n, t = self.u, self.f, self.n, self.t
        #dt is not necessarily constant:
        dt = t[n+1]-t[n]
        unew = u[n] + dt*f(u[n], t[n])
        return unew
!ec
This class is quite similar to the one above, but we have simplified the
constructor considerably, introduced a separate method for setting the initial
condition, and changed the `solve` method to take an array of time points
as argument. The latter gives a bit more flexibility than the version in
`ForwardEuler_v1`, where the stop time and number of time points were passed
as arguments to the constructor and used to compute a (constant) time step `dt`.
The `ForwardEuler_v2` version does not require the time step to be constant, and
the method will work fine if we pass it a `time_points` array with varying
distance between the time points. This can be useful if we know that the solution
varies rapidly in some time intervals and more slowly in others. However, in most cases
we will use an evenly spaced array for the `time_points` argument, for instance created using
NumPy's `linspace`, and in such cases there is not much difference between the two
classes. To consider a concrete example, the solution of the same logistic
growth problem as above, using the new class, may look as follows:
!bc pycod
problem = Logistic(0.2, 1, 0.1)
T, N = 40, 401
time = np.linspace(0,T,N)

method = ForwardEuler_v2(problem)
method.set_initial_condition(problem.U0)
u, t = method.solve(time)
!ec
